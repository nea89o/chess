<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Awesome Chess</title>
</head>
<style>
    * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
    }

    #app {
        margin: 0 auto;
        width: fit-content;
    }

    .board {
        border: 2px solid black;
        font-size: 20px;
        user-select: none;
    }

    .board-field.black {
        background: chocolate;
    }

    .board-field.white {
        background: bisque;
    }

    .board-field {
        text-align: center;
        width: 1.5em;
        border: 1px transparent;
        height: 1.5em;
    }

    .lastmove {
        border: 1px solid green;
    }

    #warn {
        display: block;
        position: fixed;
        top: 25%;
        left: 25%;
        z-index: 10;
        margin: 0 auto;
        width: 50%;
        background: coral;
        border: crimson solid 1px;
    }

    .status {
        text-align: center;
        font-family: sans-serif;
    }

    .invisible {
        display: none !important;
    }
</style>
<body>

<div id="app">
    <p class="status">You are <b>white</b></p>
</div>
<div id="warn" class="invisible">
    Connection closed
</div>
<script>
    class Board {
        constructor(elem) {
            this.socket = new WebSocket(`${location.protocol.includes('s') ? 'wss' : 'ws'}://${window.location.host}/socket`)
            this.exiting = false
            this.boardState = {}
            this.lastMove = ''
            window.addEventListener('beforeunload', () => {
                this.exiting = true
            })
            this.socket.addEventListener('message', ev => {
                const message = JSON.parse(ev.data)
                console.log(message)
                this.playerColor = message.player_color || this.playerColor
                this.boardState = parseFEN(message.board)
                this.lastMove = message.lastmove || ''
                this.synchronizeBoard()
            })
            this.socket.addEventListener('close', () => {
                if (!this.exiting)
                    document.getElementById('warn').classList.remove('invisible')
            })
            let board = document.createElement("table")
            board.className = "board"
            this.fields = {};
            for (let i = 7; i >= 0; i--) {
                let row = document.createElement("tr")
                row.className = "board-row"
                for (let j = 0; j < 8; j++) {
                    let field = document.createElement("td")
                    field.className = "board-field " + (((i + j) % 2) === 0 ? 'black' : 'white');
                    let name = indiciesToFieldName(i, j)
                    field.innerText = name;
                    field.addEventListener("dragover", ev => ev.preventDefault())
                    field.addEventListener("drop", ev => {
                        ev.preventDefault()
                        this.playMove(ev.dataTransfer.getData("text"), name)
                    })
                    this.fields [name] = field
                    row.appendChild(field)
                }
                board.appendChild(row)
            }
            elem.appendChild(board)
            this.turnIndicator = document.createElement('p')
            this.turnIndicator.className = "turn-indicator status"
            elem.appendChild(this.turnIndicator)
        }

        playMove(fromField, toField) {
            if (!this.isPlayerTurn) return
            let uci = fromField + toField
            if (((toField[1] === '8' && this.playerColor === 'white')
                    || (toField[2] === '1' && this.playerColor === 'black'))
                && (this.boardState[fromField].toUpperCase() === 'P')) {
                uci += window.prompt('promote to what')
            }
            this.socket.send(JSON.stringify({
                method: "move",
                params: {
                    move: uci
                }
            }))
        }

        get isPlayerTurn() {
            return this.playerColor === this.boardState.turn
        }

        synchronizeBoard() {
            this.turnIndicator.innerHTML = `<b>${capitalize(this.boardState.turn)}</b>s turn`
            for (let field in this.fields) {
                const fieldDOM = this.fields[field]
                fieldDOM.innerHTML = ""
                if (this.boardState[field]) {
                    let piece = document.createElement("span")
                    piece.innerText = notationToPieceUnicode(this.boardState[field])
                    piece.addEventListener("dragstart", ev => {
                        ev.dataTransfer.setData("text", field)
                    })
                    piece.draggable = this.isPlayerTurn
                    fieldDOM.appendChild(piece)
                }
                fieldDOM.classList.remove('lastmove')
                if (this.lastMove.includes(field)) {
                    fieldDOM.classList.add('lastmove')
                }
            }
        }
    }

    function capitalize(thing) {
        return thing.replace(/\b./, x => x.toUpperCase())
    }

    function indiciesToFieldName(row, col) {
        return "abcdefgh".at(col) + (row + 1)
    }

    function parseFEN(notation) {
        let row = 7;
        let col = 0;
        let board = {}
        let s = 'position'
        let error = c => {
            console.log("Error while parsing notation")
            console.log(board)
            throw "Could not parse notation: " + c
        }
        for (let c of notation) {
            if (s === 'position') {
                if (c === '/') { // Next row on /
                    if (col !== 8) {
                        throw "Row not finished"
                    }
                    row--
                    col = 0
                } else if ((c | 0) > 0) { // Skip n places on a number
                    col += (c | 0)
                } else if (c === ' ') {
                    s = 'turn'
                } else if ("KQRBNP".includes(c.toUpperCase())) {
                    board[indiciesToFieldName(row, col)] = c
                    col += 1
                } else {
                    error(c)
                }
            } else if (s === 'turn') {
                if (c === 'b') {
                    board.turn = 'black'
                } else if (c === 'w') {
                    board.turn = 'white'
                } else if (c === ' ') {
                    break
                } else {
                    error(c)
                }
            } else {
                error('Invalid state ' + s)
            }
        }
        return board
    }

    function notationToPieceUnicode(notation) {
        let white = "♔♕♖♗♘♙"
        let black = "♚♛♜♝♞♟︎"
        let names = "KQRBNP"
        let index = names.indexOf(notation.toUpperCase())
        if (index < 0) {
            return null
        }
        return (notation < 'Z' ? white : black)[index];
    }


    const board = new Board(document.getElementById("app"));

</script>


</body>
</html>